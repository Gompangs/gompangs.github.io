{"meta":{"title":"곰팡이 개발연구소","subtitle":"네임드 개발자가 되는 그날까지!","description":"개발덕후 삽질 끄적끄적..","author":"곰팡이","url":"https://gompangs.github.io"},"pages":[{"title":"about","date":"2018-11-02T04:49:35.000Z","updated":"2018-12-29T17:08:02.556Z","comments":true,"path":"about/index.html","permalink":"https://gompangs.github.io/about/index.html","excerpt":"","text":"About Me 자바 개발자(를 메인 베이스로 함) Second lang으로 Node JS, Go lang, C++에 관심이 있음 의지만 있고 공부할 시간 없음 핑계로 무언가 산출물은 없음 고성능 서버 개발을 좋아함 동시/병렬적인 로직 및 하드웨어 자원을 최대한 활용하는 것을 선호함 Spring, Spring Boot 주로 개발함 근데 CRUD만 반복하는 업무는 지루하다. Spring Cloud, Hystrix, Zuul 등에 관심이 많음 게임을 좋아함 로스트아크 / 오버워치 / 배틀그라운드 … 홈 자동화 및 개인 서버 구축에 관심 ODROID로 개인 NAS / 미디어 서버 구축하여 사용중 IoT로 스마트홈을 구축해보고 싶음 오픈소스에 관심많고 contribute를 적극적으로 하고 싶음 역시나 의지만 있지, 실천을 안한다 사용 및 새로운 기술 tracking만 적극적으로 함 깔끔한 디자인을 좋아함(개인적 취향) 개발 환경(폰트, 테마 …) 집 인테리어 주변기기 등… CareerNetmarble(2016.3 ~ NOW) 플랫폼 서버 개발(Platform Server Development) 대규모 트래픽 인증 시스템(Authentication System in Massive Traffic) 리니지2 레볼루션, 블레이드 앤 소울, 펜타스톰 … 대량 접속 트래픽 경험 사내 플랫폼 서비스 모니터링 시스템(Service Monitoring System) 솔루션 적용 X, 자체 설계 구현으로 모니터링 시스템 개발 A/B 테스트 시스템(A/B Testing System) API Gateway(Kong) 도입 및 MSA형태로 서비스 형태 개선 업무 진행 Academic background 가천대학교 컴퓨터공학 학사 4.06 / 4.5 (Gachon Univ, Bachelor, GPA 4.06 / 4.5) Interest fields 대용량 트래픽 분산 처리 시스템 Spring NoSQL Block-Chain Study Block-Chain Mastering bitcoin(https://github.com/bitcoinbook/bitcoinbook) Mastring Etherium(https://github.com/ethereumbook/ethereumbook) bitcoin과 etherium의 block chain 구현 방법과 이를 활용한 생태계 및 거래 검증 / 블록 생성 / 스마트 컨트랙트 등에 관한 공부 SRE(Site Reliability Engineering) https://landing.google.com/sre/books/ 안정적인 서비스 운영 및 devOps를 위해서 필요한 덕목/문화 등에 대한 공부 JVM Performance Tuning http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&amp;ejkGb=KOR&amp;barcode=9791186697139 자바 어플리케이션의 성능을 튜닝 Garbage Collection 이해 및 차이점 JVM Thread Performance Testing Patent"},{"title":"All Categories","date":"2018-11-02T04:36:52.436Z","updated":"2018-11-02T04:36:52.435Z","comments":true,"path":"categories/index.html","permalink":"https://gompangs.github.io/categories/index.html","excerpt":"","text":""},{"title":"projects","date":"2018-11-02T04:57:51.000Z","updated":"2018-11-02T04:59:00.107Z","comments":true,"path":"projects/index.html","permalink":"https://gompangs.github.io/projects/index.html","excerpt":"","text":"프로젝트 설명 페이지"},{"title":"search","date":"2018-12-13T15:44:24.000Z","updated":"2018-12-13T15:44:24.704Z","comments":true,"path":"search/index.html","permalink":"https://gompangs.github.io/search/index.html","excerpt":"","text":""},{"title":"All Tags","date":"2018-11-02T04:37:07.521Z","updated":"2018-11-02T04:37:07.521Z","comments":true,"path":"tags/index.html","permalink":"https://gompangs.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Test","slug":"Test","date":"2019-08-07T14:32:50.000Z","updated":"2019-08-07T14:36:46.900Z","comments":true,"path":"2019/08/07/Test/","link":"","permalink":"https://gompangs.github.io/2019/08/07/Test/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"PasswordEncoder","slug":"PasswordEncoder","date":"2019-02-26T17:41:34.000Z","updated":"2019-02-27T13:39:37.890Z","comments":true,"path":"2019/02/27/PasswordEncoder/","link":"","permalink":"https://gompangs.github.io/2019/02/27/PasswordEncoder/","excerpt":"","text":"Spring에서는 인증/권한인가 등의 처리가 필요할 때 사용하라고 만든 Spring Security 패키지가 존재한다. 그 중 유저가 입력하는 Password를 암호화해서 저장하는 방법에 대해서 알아보자 아, 그 전에 패스워드를 저장할 때 사용하는 알고리즘을 먼저 봐야 하는데 일단 패스워드는 무조건 단방향 암호화/해싱을 사용해야 한다. 한번 encode된 패스워드는 다시 복호화를 할 수 없도록 해야 하고(AES,RSA,DES… 등의 양방향 암호화를 사용하면 안된다는 뜻이다) 이를 비교하는 로직만 같은지 아닌지만 판단할 수 있게 만들어야 한다. 이를 지키지 않을 경우 최악은 DB에 저장된 유저의 패스워드가 다 복호화 되어 개인정보가 털리던.. 혹은 결제와 관련된 경우 직접적인 타격을 받게될 수도 있다. 혹여나, 지금이라도 패스워드를 AES 등으로 저장하여 사용하고 있다면 당장 해싱하는 방향으로 바꾸도록 하자 그럼 유저가 패스워드를 잃어버렸을때 찾아주는 방법이 없지않냐! 할 수 있는데, 잘 생각해보면 우리 주위의 포털사이트나 웹사이트에서는 이미 “패스워드 변경 메일” 혹은 SMS등으로 인증을 해서 “새로운 비밀번호” 를 입력받도록 유도를 하고 있음을 알 수 있다. 한번 encode된 패스워드를 다시 복호화할 이유가 없다는건 이런 해결책이 있기 때문이기도 하고, 완벽한 보안은 없으면서도 그나마 강력한 보안성을 유지하기 위해서는 위와 같은 방법을 취하는게 옳은 방법이다. PasswordEncoder Interface123456789public interface PasswordEncoder &#123; String encode(CharSequence var1); boolean matches(CharSequence var1, String var2); default boolean upgradeEncoding(String encodedPassword) &#123; return false; &#125;&#125; 인터페이스를 먼저 보면, 간단하게 encode()와 matches()로 구성되어 있다. encode 는 실제로 패스워드를 암호화 할 때 사용하고 matches 는 사용자에게 입력받은 패스워드를 비교하고자 할 때 사용한다 default 메서드로 구현된 upgradeEncoding 은 기본적으로 false를 리턴하나, Custom하게 구현할 경우 이를 기반으로 더 강력한 암호화를 실행할 것인지에 대한 로직처리를 해주면 될 것 같다. upgradeEncoding() : true if the encoded password should be encoded again for better security, else false. Spring에서 기본적으로 제공되는 PasswordEncoder의 종류는 위와 같은데 BCryptPasswordEncoder, DelegatingPasswordEncoder, SCryptPasswordEncoder, Pbkdf2PasswordEncoder 가 decrepated 되지 않은 PasswordEncoder 이므로 이들 클래스를 살펴보도록 하자. BCryptPasswordEncoder \u0011\u0011Implementation of PasswordEncoder that uses the BCrypt strong hashing function. Clients can optionally supply a “strength” (a.k.a. log rounds in BCrypt) and a SecureRandom instance. The larger the strength parameter the more work will have to be done (exponentially) to hash the passwords. The default value is 10. BCrypt 라는 해시 함수를 사용한 구현체이다. 단순히 해시를 하는것 뿐만 아니라 Salt 를 넣는 작업까지 하므로, 입력값이 같음에도 불구하고 매번 다른 encoded된 값을 return 해주게 된다. 1234567891011121314public String encode(CharSequence rawPassword) &#123; String salt; if (this.strength &gt; 0) &#123; if (this.random != null) &#123; salt = BCrypt.gensalt(this.strength, this.random); &#125; else &#123; salt = BCrypt.gensalt(this.strength); &#125; &#125; else &#123; salt = BCrypt.gensalt(); &#125; // salt를 generate하고 rawPassword와 salt를 이용해 hashing을 한다 return BCrypt.hashpw(rawPassword.toString(), salt);&#125; 그러므로 Bcrypt를 이용했을 경우에는 matches 함수를 잘 확인하고 사용하는게 좋다(입력값이 같아도 매번 출력물이 다르기 때문에 equal로 비교하려고 하면 패스워드가 계속 일치하지 않는 상황을 겪게될 수 있다) 12345678String input = \"hello world\";String encoded = passwordEncoder.encode(input);// trueAssert.assertTrue(passwordEncoder.matches(input, encoded));// falseAssert.assertEquals(passwordEncoder.encode(input), passwordEncoder.encode(input)); “hello world” 라는 문자열이 있을 때 이를 encode한 값을 encoded에 넣고 테스트를 해보면, matches 로 확인을 했을 경우에는 예상대로 true 가 리턴되지만, equals 로 확인을 해보면 값이 false로 리턴이 되는 것을 알 수 있다. 참고 : matches(rawPassword, encoded) 이다. rawPassword parameter에 암호화된 값을 넣지 말고, 사용자가 입력한 패스워드를 그대로 넣어주도록 하자 DelegatingPasswordEncoder A password encoder that delegates to another PasswordEncoder based upon a prefixed identifier. PasswordEncoder를 여러개 선언한 뒤, 상황에 맞게 골라쓸 수 있도록 지원하는 Encoder이다. 12345678String idForEncode = \"bcrypt\";Map encoders = new HashMap&lt;&gt;();encoders.put(idForEncode, new BCryptPasswordEncoder());encoders.put(\"noop\", NoOpPasswordEncoder.getInstance());encoders.put(\"pbkdf2\", new Pbkdf2PasswordEncoder());encoders.put(\"scrypt\", new SCryptPasswordEncoder());encoders.put(\"sha256\", new StandardPasswordEncoder());PasswordEncoder passwordEncoder = new DelegatingPasswordEncoder(idForEncode, encoders); 위와 같이 선언을 하게 되면 PasswordEncoder에 선언된 bcrypt, noop, pbkdf2, scrypt, sha256 PasswordEncoder들이 들어가게 되고, 마지막에 선언했을 때 idForEncode를 bcrypt로 줬으니 최종으로 encoding이 되는 값은 bcrypt로 해싱이 된 패스워드가 return이 된다. 그리고 맨 앞에 prefix로 암호화를 한 방법이 붙는다 1&#123;bcrypt&#125;$2a$10$UemKUf.cijGeJz6CJ/81auJKQVU0syWTJq2O.UGQXga9G.SCCKDR. 위와 같이 맨 앞에 prefix로 저렇게 붙게 되어서, 어떤 암호화를 사용해서 encode를 했는지 구분하는 목적인것 같다. 여러가지의 패스워드 암호화를 뒀을 때 매번 DI를 해서 안써도 되니 그럴때 사용하면 유용할 것으로 추측.. matches를 호출하는건 인터페이스가 동일하다. prefix가 들어간 password를 앞에서 알아서 짤라서 맞는 encode방식으로 변환을 해준다. SCryptPasswordEncoder Implementation of PasswordEncoder that uses the SCrypt hashing function. Clients can optionally supply a cpu cost parameter, a memory cost parameter and a parallelization parameter. 좀 신기한놈인데, Scrypt 해시 함수를 사용하고, 추가적으로 cpu와 memory의 cost parameter를 넘길수 있게 되어있다. Scrypt는 실제로 Salsa20 라는 해싱방식을 사용한다고 한다. 그리고 왠지모르게 Javadoc에 이 패스워드 해싱방식을 추천하지 않는다고 쓰여있다(..?). 해당 글을 읽다보니 보안문제가 존재하지만 그래도 여전히 쓸만하다… 라는 느낌의 분석이 있었다(https://blog.ircmaxell.com/2014/03/why-i-dont-recommend-scrypt.html) Pbkdf2PasswordEncoder A PasswordEncoder implementation that uses PBKDF2 with a configurable number of iterations and a random 8-byte random salt value 이름이 매우 특이한데, PBKDF2 라는 해싱을 사용하는 이놈의 이름은(Password-Based Key Derivation Function 2) 의 뜻을 가지고 있다. 네이버 D2 포스팅에도 한번 소개가 되었었다 이 encoder는 해싱+salt를 동시에 진행한다(Bcrypt와 동일) 다만 차이점은 아래와 같다 Pbkdf2PasswordEncoder : salt가 8bytes 랜덤 값이다 BCryptPasswordEncoder : salt가 72bytes 랜덤값이다 그렇기 때문에 bcrypt가 좀더 안전(하다고 말하기엔 좀 그렇지만, collision이 발생할 수학적 확률이 더 낮다고 볼 수 있다) 하기 때문에 Spring의 기본 PasswordEncoder는 bcrypt를 권장하는 것으로 보인다 ConclusionBCryptPasswordEncoder 혹은 Pbkdf2PasswordEncoder 를 사용하자 인 것 같은데, JMH Benchmark를 돌려본 결과 Pbkdf2의 성능이 상대적으로 낮게 측정이 되었다. Pbkdf2가 좀더 심플하고, Random으로 받는 key bytes도 작아서 좋은 성능이 나올줄 알았는데 의외였다. Throughput : scrypt &gt; bcrypt &gt;&gt;&gt; pbkdf2 평균 소모되는 operation 별 avg time또한 위와 같다. 단일 쓰레드에서 암호화 되는 encode() 만 테스트해본 결과이다. 테스트 코드 1234567891011121314151617181920212223242526272829303132333435363738394041@State(Scope.Benchmark)public class EncodeTest &#123; private BCryptPasswordEncoder bCryptPasswordEncoder; private SCryptPasswordEncoder sCryptPasswordEncoder; private Pbkdf2PasswordEncoder pbkdf2PasswordEncoder; private final String targetString = \"HELLO WORLD ENCODE TEST\"; @Setup(Level.Invocation) public void setUp() &#123; bCryptPasswordEncoder= new BCryptPasswordEncoder(); sCryptPasswordEncoder = new SCryptPasswordEncoder(); pbkdf2PasswordEncoder = new Pbkdf2PasswordEncoder(); &#125; @Benchmark @Fork(value = 1, warmups = 1) @BenchmarkMode(Mode.All) public void bcrypt()&#123; bCryptPasswordEncoder.encode(targetString); &#125; @Benchmark @Fork(value = 1, warmups = 1) @BenchmarkMode(Mode.All) public void scrypt()&#123; sCryptPasswordEncoder.encode(targetString); &#125; @Benchmark @Fork(value = 1, warmups = 1) @BenchmarkMode(Mode.All) public void pbkdf2()&#123; pbkdf2PasswordEncoder.encode(targetString); &#125; public static void main(String[] args) throws IOException, RunnerException &#123; org.openjdk.jmh.Main.main(args); &#125;&#125; 테스트 결과 123456789101112131415161718192021222324252627282930313233343536373839# Run complete. Total time: 00:14:06Benchmark Mode Cnt Score Error UnitsEncodeTest.bcrypt thrpt 20 12.021 ± 0.038 ops/sEncodeTest.pbkdf2 thrpt 20 2.279 ± 0.015 ops/sEncodeTest.scrypt thrpt 20 16.036 ± 0.143 ops/sEncodeTest.bcrypt avgt 20 0.083 ± 0.001 s/opEncodeTest.pbkdf2 avgt 20 0.440 ± 0.002 s/opEncodeTest.scrypt avgt 20 0.066 ± 0.002 s/opEncodeTest.bcrypt sample 241 0.085 ± 0.001 s/opEncodeTest.bcrypt:bcrypt·p0.00 sample 0.082 s/opEncodeTest.bcrypt:bcrypt·p0.50 sample 0.083 s/opEncodeTest.bcrypt:bcrypt·p0.90 sample 0.087 s/opEncodeTest.bcrypt:bcrypt·p0.95 sample 0.091 s/opEncodeTest.bcrypt:bcrypt·p0.99 sample 0.117 s/opEncodeTest.bcrypt:bcrypt·p0.999 sample 0.168 s/opEncodeTest.bcrypt:bcrypt·p0.9999 sample 0.168 s/opEncodeTest.bcrypt:bcrypt·p1.00 sample 0.168 s/opEncodeTest.pbkdf2 sample 60 0.439 ± 0.004 s/opEncodeTest.pbkdf2:pbkdf2·p0.00 sample 0.430 s/opEncodeTest.pbkdf2:pbkdf2·p0.50 sample 0.434 s/opEncodeTest.pbkdf2:pbkdf2·p0.90 sample 0.452 s/opEncodeTest.pbkdf2:pbkdf2·p0.95 sample 0.455 s/opEncodeTest.pbkdf2:pbkdf2·p0.99 sample 0.462 s/opEncodeTest.pbkdf2:pbkdf2·p0.999 sample 0.462 s/opEncodeTest.pbkdf2:pbkdf2·p0.9999 sample 0.462 s/opEncodeTest.pbkdf2:pbkdf2·p1.00 sample 0.462 s/opEncodeTest.scrypt sample 328 0.063 ± 0.001 s/opEncodeTest.scrypt:scrypt·p0.00 sample 0.059 s/opEncodeTest.scrypt:scrypt·p0.50 sample 0.061 s/opEncodeTest.scrypt:scrypt·p0.90 sample 0.071 s/opEncodeTest.scrypt:scrypt·p0.95 sample 0.073 s/opEncodeTest.scrypt:scrypt·p0.99 sample 0.081 s/opEncodeTest.scrypt:scrypt·p0.999 sample 0.090 s/opEncodeTest.scrypt:scrypt·p0.9999 sample 0.090 s/opEncodeTest.scrypt:scrypt·p1.00 sample 0.090 s/opEncodeTest.bcrypt ss 0.090 s/opEncodeTest.pbkdf2 ss 0.824 s/opEncodeTest.scrypt ss 0.355 s/op","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://gompangs.github.io/categories/JAVA/"},{"name":"Security","slug":"JAVA/Security","permalink":"https://gompangs.github.io/categories/JAVA/Security/"}],"tags":[{"name":"java","slug":"java","permalink":"https://gompangs.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://gompangs.github.io/tags/spring/"},{"name":"PasswordEncoder","slug":"PasswordEncoder","permalink":"https://gompangs.github.io/tags/PasswordEncoder/"},{"name":"BCryptPasswordEncoder","slug":"BCryptPasswordEncoder","permalink":"https://gompangs.github.io/tags/BCryptPasswordEncoder/"},{"name":"SCryptPasswordEncoder","slug":"SCryptPasswordEncoder","permalink":"https://gompangs.github.io/tags/SCryptPasswordEncoder/"},{"name":"Pbkdf2PasswordEncoder","slug":"Pbkdf2PasswordEncoder","permalink":"https://gompangs.github.io/tags/Pbkdf2PasswordEncoder/"},{"name":"DelegatingPasswordEncoder","slug":"DelegatingPasswordEncoder","permalink":"https://gompangs.github.io/tags/DelegatingPasswordEncoder/"},{"name":"SHA","slug":"SHA","permalink":"https://gompangs.github.io/tags/SHA/"},{"name":"Salt","slug":"Salt","permalink":"https://gompangs.github.io/tags/Salt/"},{"name":"Hash","slug":"Hash","permalink":"https://gompangs.github.io/tags/Hash/"}]},{"title":"Spring DispatcherServlet","slug":"dispatcherServlet","date":"2019-02-17T14:30:11.000Z","updated":"2019-08-07T14:32:21.966Z","comments":true,"path":"2019/02/17/dispatcherServlet/","link":"","permalink":"https://gompangs.github.io/2019/02/17/dispatcherServlet/","excerpt":"","text":"![DispatcherServlet 구조](/images/huiyV.jpgz DispatcherServlet Javadoc 원문 설명 DispatcherServlet은 Spring의 모든 HTTP Call을 클라이언트(browser, http client …) 받아서 View 혹은 데이터를 내려주는 역할을 한다. 그리고 Handler를 등록해서 편리하게 url 매핑을 하거나, Exception Handling을 하는 것을 지원한다. Spring에서 제공하는 servlet은 유연한 interface를 가지고 있고, 적절한 adapter class를 사용해서 이를 handling할 수 있으며, MVC Framework의 기본적인 기능을 제공한다. MVC Pattern을 먼저 알아봐야 할 것 같은데, 이 아키텍쳐가 기본적인 MVC Pattern이며, 아래의 구성요소를 가지고 있다 Controller : 유저가 사용하는 url로 구성이 되며, business logic을 처리해서 model에 값을 전달한다 Model : Controller에서 처리된 데이터를 View로 내려주기 위해서 사용된다 View : User에게 실제적으로 보여질 데이터를 처리한다 매번 이런 패턴을 익히 들었을 법 한데, 실제로 Spring에서 이러한 패턴이 어떻게 활용되는지를 알아보자 Controller 12345678910@Controllerpublic class ExampleController &#123; @GetMapping(\"/foo\") @ResponseBody public ResponseEntity foo(Bar bar)&#123; // write logic of processing `foo` return ResponseEntity.ok().body(new Bar()); &#125; &#125; Controller는 간단하게 위와 같이 나타낼 수 있다. 유저가 요청한 url에 대한 mapping(/foo)에 대해서 요청을 처리 받고, 해당 logic을 처리한 다음에 값을 return해주는 역할을 담당한다. 위의 경우는 @ResponseBody Annotation이 달려있기 때문에 View를 return하는게 아니라, Bar 라는 객체를 JSON으로 wrapping 해서 내려주는 케이스인데, Spring에서 View를 내려주려면 아래와 같이 해야 한다 1234567@Controllerpublic class ViewController &#123; @GetMapping(\"/foo/view\") public String foo() &#123; return \"foo\"; &#125;&#125; 위와 같이 코드를 작성하게 되면 Spring 내부에서 ViewResolver가 동작해서 foo 라는 view를 찾아서 View를 유저에게 return을 해주게 된다. 공식적으로 지원하게 되는 View template는 JSP, Thymeleaf, FreeMarker, Groovy, Jade4j, Velocity, JMustache, Pebble 이 있다. DispatcherServlet에서는 @Controller 어노테이션이 달린 클래스나, @RequestMapping 어노테이션이 달린 메서드가 기본적으로 auto-scan 되고 해당 url 혹은 beanName을 기반으로 등록이 된다. 이는 ApplicationContext 에 추가가 되며(@Bean 으로 등록이 된다는 말), RequestMappingHandlerMapping이 초기화 될 때 ApplicationContext에 추가된 @Controller 에 해당하는 handler들을 모두 불러와서 해당 url에 맞게 DispatcherServlet에 등록이 되게 된다. Exception resolution strategy가 존재하는데 ExceptionHandlerExceptionResolver ResponseStatusExceptionResolver, DefaultHandlerExceptionResolver. 등을 사용해서 기본적인 Exception Handling을 한다. Whitelabel Error 라고 하면서 나오는 에러는 이 Resolver들에 의해서 Exception이 Catch되어 나타나게 되는 페이지이다. 그 밖에도 View를 찾기 위한 ViewResolver , Multipart를 Handling하기 위한 MultipartResolver , 접근하는 사용자의 locale을 알기 위한 LocaleResolver. 그리고 페이지의 테마를 위한(?) ThemeResolver 정도가 기본으로 제공되는 Resolver 라고 보면 되겠다. 이런식으로 기본적인 MVC패턴을 이용해서 웹서비스를 하기 위한 기본적인 핸들러들이 등록이 되어 있으며, 필요에 따라 Customizing 하거나 Interface를 이용해서 새로 만들어서 추가를 하여 사용하기도 한다. 그럼 실제로 Request가 들어왔을 때 어떤 call stack으로 호출이 되는지 한번 알아보자 임의로 Controller에서 RuntimeException을 throw해봤다. (“/“ url 을 GET으로 호출) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 ┌───────────────────────────┐ │ java.lang.Thread.run() │ └───────────────────────────┘ │ ▼┌─────────────────────────────────────────────┐│java.util.concurrent.ThreadPoolExecutor.run()│└─────────────────────────────────────────────┘ │ ▼┌─────────────────────────────────────────────┐│ undertow.server.HttpServerExchange.run() │└─────────────────────────────────────────────┘ │ ▼┌─────────────────────────────────────────────┐│ undertow.servlet.handleRequest() │└─────────────────────────────────────────────┘ │ ▼┌─────────────────────────────────────────────┐│ AbstractSecurityContextAssociationHandler │ // SpringSecurity로 인해 호출됨└─────────────────────────────────────────────┘ │ ▼┌─────────────────────────────────────────────┐│ AuthenticationMechanismsHandler │ // SpringSecurity 인증flow └─────────────────────────────────────────────┘ │ ▼┌─────────────────────────────────────────────┐│ ServletDispatchingHandler │ // 드디어 이때 call└─────────────────────────────────────────────┘ │ ▼┌─────────────────────────────────────────────┐│ FilterChainImpl │ // Charset, Security filter 호출└─────────────────────────────────────────────┘ │ ▼┌─────────────────────────────────────────────┐│ ServletHandler.service() │ └─────────────────────────────────────────────┘ │ ▼┌─────────────────────────────────────────────┐│ HttpServlet.service() │ // undertow -&gt; spring servlet└─────────────────────────────────────────────┘ │ ▼┌─────────────────────────────────────────────┐│ FrameworkServlet.doGet() │ // doGet()을 호출한다└─────────────────────────────────────────────┘ │ ▼┌─────────────────────────────────────────────┐│ FrameworkServlet.processRequest() │ // 최종└─────────────────────────────────────────────┘ 아마 상황에 따라 호출되는 filter와 handler가 다르겠지만, 기본적으로는 위와 같이 호출이 되는걸 볼 수 있다 (spring boot tomcat -&gt; undertow로 교체하여 호출해본 결과) 원래 Spring boot에 오기 전에 Spring Framework를 사용했을 때는 web.xml을 수정해야 했던적이 있었다. web.xml에 url을 등록해서 해당 url로 들어왔을때의 Servlet Handler를 직접 지정해주는 방식을 사용했는데, 현재는 대부분 DispatcherServlet을 따로 설정하지 않고 기본적으로 모든 Request에 대해서 요청을 받는 DispatcherServlet을 1개 두고, 뒤에 Handler(@Controller) 를 둬서 처리하는 방식이 일반적이다. 1234567891011121314&lt;web-app&gt; &lt;servlet&gt; &lt;servlet-name&gt;example&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;example&lt;/servlet-name&gt; &lt;url-pattern&gt;*.form&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 예전에는 위와 같이 DispatcherServlet을 servlet으로 등록한 뒤, 해당 servlet을 직접 mapping(servlet-mapping) 해주는 작업을 해주곤 했었다.. 번외로 Spring에서 기본적으로 지원하는 Servlet 엔진으로는 Tomcat, Undertow, Jetty 가 있다. (기본으로는 Embedded Tomcat이 사용된다) 인터페이스를 정의해두고 내부적으로 돌아가는 Setvlet Engine은 이를 구현함으로써 다양한 ServletEngine으로 교체하여 사용할 수 있다는 장점이 있다.","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://gompangs.github.io/categories/JAVA/"},{"name":"Spring","slug":"JAVA/Spring","permalink":"https://gompangs.github.io/categories/JAVA/Spring/"}],"tags":[{"name":"java","slug":"java","permalink":"https://gompangs.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://gompangs.github.io/tags/spring/"},{"name":"DispatcherServlet","slug":"DispatcherServlet","permalink":"https://gompangs.github.io/tags/DispatcherServlet/"},{"name":"mvc","slug":"mvc","permalink":"https://gompangs.github.io/tags/mvc/"},{"name":"Model","slug":"Model","permalink":"https://gompangs.github.io/tags/Model/"},{"name":"View","slug":"View","permalink":"https://gompangs.github.io/tags/View/"},{"name":"Controller","slug":"Controller","permalink":"https://gompangs.github.io/tags/Controller/"}]},{"title":"Prometheus 공부 및 Java client 연동","slug":"prometheus","date":"2018-12-13T15:55:00.000Z","updated":"2019-02-17T17:43:25.700Z","comments":true,"path":"2018/12/14/prometheus/","link":"","permalink":"https://gompangs.github.io/2018/12/14/prometheus/","excerpt":"","text":"개요Prometheus 는 오픈소스 모니터링 솔루션이다. (https://prometheus.io/) 크게 Prometheus 서버와, 메트릭 정보를 export할 export node로 구성이 되어 있다 구조가 좀 일반적인 모니터링 시스템과는 다르다는걸 느낄수가 있는데, 원래는 대부분의 솔루션이 메트릭을 수집할 때 메트릭이 발생한 서버에서 중앙 서버로 데이터를 전송해주는 구조로(push) 되어 있지만, 프로메테우스 같은 경우는 신기하게도 중앙서버(prometheus server)에서 메트릭을 polling 해서 가져가도록 구성이 되어 있다. 장점이 솔루션을 쓰게 되면 얻을 수 있는 장점은, 아무래도 pull 방식의 구조를 채택함으로써 모든 메트릭에 대한 데이터를 중앙 서버로 보내지 않아도 된다는 점이다. 대부분의 모니터링 시스템 구조는 push방식으로 메트릭이 발생하면 해당 메트릭을 서버로 보내는 방식을 채택하고 있는데, 만약 부하가 높은 상황에서 그런 메트릭들을 수집하기 위해 전송하는 부분이 생긴다면? 부하와 더불어서 실제 어플리케이션에 문제를 유발할 수 있는 fail point가 생기는 것이다 Prometheus의 특성 상, 모든 데이터를 수집하지 않고 일정 주기(default 15s)로 발생하는 메트릭을 수집하여 추이나 모니터링을 어플리케이션에 무리 없이 하기 때문에 이러한 부분에서 매력적인 솔루션이라고 말할 수 있다. 또한 현재 Prometheus를 사용하고 있는 Vendor와 open-source들이 상당히 많다. 구조가 복잡하지 않고 간단하기 때문에 특정 솔루션에 대한 export를 하는 것이 어렵지 않다. 특히 Kubernetes와 Docker환경에서의 서비스의 메트릭을 수집하고 분석하는 대에 집중적으로 많이 사용이 되고 있다. 단점Scale-out이 안된다(정확히 말하자면 억지로 되지만, 이것은 사실상 clustering이 아니라고 본다) 문서에 적혀있기를 Prometheus를 여러대에 구성해서 사용하려면 Prometheus에 Prometheus를 연결해서.. Hierarchy 구조를 만들어서 사용을 하면 된다 라고 하는데! 세상에 너무 지저분한 구조인 것 같다. 대부분 Clustering이라 함은.. Host를 여러대 두고 gossip을 통해 서로를 discovery 하고, 데이터를 sharding 및 replication을 해서 특정 노드가 죽어도 H/A(High Availability)를 보장해주는게 되어야 하는데 Prometheus 같은 경우는 그런 고가용성을 지원한다는 개념보다는 간단한 구조로 손쉽게 사용을 할 수 있다에 목적이 있는 것 같다. 또한, 위의 장점이 또 단점이 될 수 있는 부분인데 모든 메트릭을 전송하지 않기 때문에 사실상 “추이”를 보는데는 좋지만 APM(Application Performance Monitoring)과 같이 발생한 모든 로그를 추적하고 문제가 발생했을 때 이를 검색해서 어떤 일이 있었는지의 원인을 밝히고자 했을때는 적합하지 않은 솔루션이다. 정리따라서 위의 장점만 가지고도 서비스 모니터링에 부합하는지를 잘 체크를 해서 도입을 해야할 필요성이 있다. 장/단점이 확실한 솔루션이다보니 push방식의 비슷한 솔루션들에 비해서는 모호한 부분은 없는 것 같다고 생각이 된다. 서버 내부 모듈Retrival메트릭을 수집할 대상 서버에 접근해서(HTTP) 메트릭을 가져오거나, 아니면 Pushgateway를 통해서 접근할 수 없는 곳에 있는 데이터(inner server, firewall 내부의 metric 등)를 가져오는 등의 역할을 하게 된다 Pushgateway는 쉽게말해 Proxy Forwarding을 해서 접근할 수 없는 곳에 데이터가 존재하는 경우 이때 사용할 수 있는 대안이라고 보면 된다. 사내망에 데이터가 있어서 외부에서 scrape를 하고싶어도 접근이 안되는 경우 말이다. 아무래도 메트릭 발생 서버 -&gt; 메트릭 집계 서버 가 아닌 메트릭 집계서버가 메트릭 발생 서버에 직접 접근을 해서 데이터를 가져가기 때문에 존재하는 개념인 듯 하다. TSDB(Time-series Database)이렇게 가져온 데이터를 저장하고, 시간의 흐름에 따라 조회를 할 수 있어야 하므로 시-계열 데이터(time-series) 를 저장할 수 있는 저장소가 prometheus 내부에 구현이 되어 있다. 데이터를 저장하는 방법은 Local Storage, Remote Storage를 이용하는 방법 두 가지가 존재한다. 대부분 Local Storage를 쓰는걸로 default로 사용하겠지만 필요에 따라서 원격지에 있는 서버에 데이터를 저장해서 사용을 한다고 한다 내부 저장소는 Google에서 만든 Level DB를 사용하는걸로 보인다 light-weight의 Key-value 저장소이며 전반적으로 뛰어난 성능을 보이기에 여러군데서 차용해서 쓰는것 같다.(프로메테우스도) 프로메테우스의 메트릭은 위와 같이 수집이 되는데 1메트릭명&#123;필드1=값, 필드2=값&#125; 샘플링데이터 실제로 timestamp값은 프로메테우스 서버 내부에서 저장될 때 같이 넣게 되고 export하는 부분에서는 메트릭명-샘플링데이터와 같은 형태로 보여지게 된다. 이게 Spring boot에 Prometheus export 라이브러리를 붙인 모습인데, 보다시피 많은수의 메트릭이 발생을 하게 되고, 이를 text/html 방식으로 특정 url(대부분 /metrics)로 export를 해두게 되면, prometheus 서버가 이를 긁어가서 데이터를 저장하는 구조이다. HTTP Serverprometheus에 저장된 데이터를 조회하기 위해서는 내부적으로 HTTP 서버가 필요하다. 따라서 prometheus는 데이터를 가져가기 위한 프로토콜로 HTTP REST API를 제공하고, 직접 API를 통해 데이터를 가져가던지, Web UI 대시보드에서 데이터를 조회한다던지, Grafana를 통해 더욱 자세하고 깔끔한 데이터 시각화를 할 수 있다 Web UI원래는 시각화를 위한 툴을 붙여서 보는게 더 좋지만, 그렇게 하지 않아도 기본적으로 제공하는 Dashboard가 있다. 위와 같이 Bootstrap으로 작성된듯한 투박한 대시보드가 제공이 되고, 간단하게 보고싶은 메트릭에 대한 그래프를 볼 수 있는 정도이다. 한 대시보드에 여러개의 메트릭의 추이를 보고싶다던지, 다른 그래프 형식으로 보고싶다던지 하는 것들은 지원이 되지 않으며 이는 Grafana를 통해 시각화가 가능하니 그쪽을 보도록 하자. Alert Manager모니터링 시스템이니, 문제가 발생하면 이를 알람으로 보내주는 역할도 있어야한다. Alertmanager는 Prometheus에서 문제가 발생했다고 생각되는 시점에 slack, hipchat 등을 통해 알람을 보내준다. 알람을 거는 기준은 Rule을 작성해서 load시키는 방식으로 동작하는데 1expr: job:request_latency_seconds:mean5m&#123;job=&quot;myjob&quot;&#125; &gt; 0.5 와 같이 expression을 작성하는 것으로 알람을 전송할 수 있다. 특정 메트릭의 값이 어느정도 선(threshold)을 넘는다거나, 낮아진다거나 하는 메트릭을 보고 판단을 할 수 있다. 다만, 이 또한 Grafana를 사용하게 된다면 Grafana에서도 동일하게 알람매니저를 제공을 하고 있는데, 아무래도 Grafana쪽이 사용하기 더 쉽고 직관적이기 때문에 이걸 직접 사용할까는 싶지만, 그래도 expression을 이용해서 더 복잡한 조건을 걸어서 알람을 노티해주는 방식이 있다는건 좋다. Prometheus Server 설치Installation일단 client를 만져보기 전에 prometheus 서버를 설치를 해보도록 하자. 다운로드는 https://prometheus.io/download/#prometheus 에서 할 수 있다 prometheus 서버 말고도 각종 exporter가 있다(node js, alertmanager 등).. 여기서는 prometheus server만 받아서 맞는 운영체제 버전으로 받자 본인은 odroid의 armv7을 사용하고 있어서 해당 바이너리로 받게 되었고, 1234wget https://github.com/prometheus/prometheus/releases/download/v2.5.0/prometheus-2.5.0.linux-armv7.tar.gztar xvfz prometheus-2.5.0.linux-armv7.tar.gzcd prometheus-2.5.0.linux-armv7./prometheus 로 바로 실행을 할 수 있다. 다만 지금은 서버가 뜨긴 하지만 아무런 메트릭을 수집하지 않고있다. 이는 prometheus.yml에서 scape를 할 target을 지정하지 않았기 때문이다. 지금은 단순히 9090포트로 접근을 해보면 Prometheus의 대시보드를 볼 수 있을것이다 대시보드에서 무언가를 보기 위해서는 일단 prometheus.yml 의 내용을 보도록 하자 prometheus.yml1234567891011121314151617181920212223242526272829# my global configglobal: scrape_interval: 15s # Set the scrape interval to every 15 seconds. Default is every 1 minute. evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute. # scrape_timeout is set to the global default (10s).# Alertmanager configurationalerting: alertmanagers: - static_configs: - targets: # - alertmanager:9093# Load rules once and periodically evaluate them according to the global 'evaluation_interval'.rule_files: # - \"first_rules.yml\" # - \"second_rules.yml\"# A scrape configuration containing exactly one endpoint to scrape:# Here it's Prometheus itself.scrape_configs: # The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config. - job_name: 'prometheus' # metrics_path defaults to '/metrics' # scheme defaults to 'http'. static_configs: - targets: ['localhost:9090'] 설정이 다른 모니터링 서비스들에 비해서는 매우 간단한 편이다. (모든 설정이 간편한건 아니다. default로 설정 되어있는 config가 간단해서 그렇지, 실제로 모든 config의 field를 보면 상당히 양이 많다. 자세한건 https://prometheus.io/docs/prometheus/latest/configuration/configuration/) config 설명 global.scrape_interval : 몇 초 단위로 메트릭을 수집할 지를 결정(15초로 기본으로 되어 있는데, 이를 수정하여 1초단위로 수집을 할 지.. 10초 단위로 수집할지.. 1분 단위로 수집할지를 결정할 수 있다) global.evaluation_interval : 이건 alerting rule을 어느 주기로 evaluate를 할 것인지에 대한 설정이다. evaluate를 하게되면 그 결과를 바탕으로 (inactive, pending, firing) 의 세 state로 구분이 되고 그 상태를 기반으로 alertmanager에서 알람을 발송할 지 안할지를 결정할 수 있다 alertmanager의 rule은 위에서 언급한대로 expression을 사용해서 설정을 할 수 있다 alerting : alertmanager의 target port를 지정할 수 있다. prometheus를 실행하면 alertmanager가 자동으로 같이 뜨는게 아니라, alertmanager를 download해서 같이 구동을 시켜줘야 한다 rule_files : expression으로 구성된 rule file의 path를 지정해준다. 복수개의 파일을 지정할 수 있다 scrape_config : 이부분이 중요하다. job_name : 메트릭을 수집해서 구분을 할 네이밍을 지정 static_configs.targets : 실제 메트릭을 수집할 서버의 주소를 지정한다. 리스트로 구성이 되어 있으며 여러개의 호스트를 지정할 수 있다 간단하게 static_configs의 target만 고쳐서 prometheus를 띄워보도록 하자 1- targets: ['192.168.0.3:9090'] 서버가 잘 실행이 되면 위와 같이 Server is ready to receive web requests. 라는 메세지가 나오게 된다. 이제 메트릭을 수집하기 위해 sample client를 만들어봐야하는데, 간단하게 spring boot로 구성을 해서 띄워보도록 하겠다. 샘플 프로젝트는 github에 올려놨으니 보고 참고를 하면 좋을 것 같다. spring boot sample project : https://github.com/Gompangs/prometheus-client-sample Spring Boot Sample Client(Java)프로젝트 생성pom.xml에 아래의 dependency를 추가하게 되면 prometheus client가 추가가 되게 된다. 사실 이런 방식 말고 spring boot용 prometheus client가 존재를 해서 그걸 dependency로 가져오게 되면 훨씬 간단하게 바로 사용을 할 수 있는데, 어떻게 돌아가는지를 직접 보면서 metric을 export를 해보기 위해서 client 모듈을 직접 가져와서 사용해보도록 하자. 참고. Spring boot용 client는 actuator를 활용해서 구현이 되어 있다(https://www.callicoder.com/spring-boot-actuator-metrics-monitoring-dashboard-prometheus-grafana/) 를 참고하면 연동방법에 대해 나와 있다. 123456789101112131415161718&lt;!-- The client --&gt;&lt;dependency&gt; &lt;groupId&gt;io.prometheus&lt;/groupId&gt; &lt;artifactId&gt;simpleclient&lt;/artifactId&gt; &lt;version&gt;0.6.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Hotspot JVM metrics--&gt;&lt;dependency&gt; &lt;groupId&gt;io.prometheus&lt;/groupId&gt; &lt;artifactId&gt;simpleclient_hotspot&lt;/artifactId&gt; &lt;version&gt;0.6.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Exposition HTTPServer--&gt;&lt;dependency&gt; &lt;groupId&gt;io.prometheus&lt;/groupId&gt; &lt;artifactId&gt;simpleclient_httpserver&lt;/artifactId&gt; &lt;version&gt;0.6.0&lt;/version&gt;&lt;/dependency&gt; dependency를 추가하고, spring boot dependency를 추가하고나서 Java bean config쪽을 구성해보자 1234567891011121314@Configuration@Slf4jpublic class PrometheusConfig &#123; @PostConstruct public void init()&#123; DefaultExports.initialize(); // Export JVM Metrics into http endpoint &#125; @Bean public HTTPServer prometheusServer() throws IOException &#123; log.info(\"promethues server has started\"); return new HTTPServer(9090); &#125;&#125; 보면 그냥 configuration 클래스가 로딩될 때, DefaultExports로 initialize를 해주고, prometheus 서버를 띄워주는 역할만 하고 있다. 이렇게 구성해서 띄워보면, 실제로 9090포트로 prometheus metric exporter가 구동이 되게 된다. 접근해보면 아래와 같은 페이지가 나오게 된다 12345678910111213141516171819202122232425# HELP jvm_memory_bytes_used Used bytes of a given JVM memory area.# TYPE jvm_memory_bytes_used gaugejvm_memory_bytes_used&#123;area=\"heap\",&#125; 8.0815512E7jvm_memory_bytes_used&#123;area=\"nonheap\",&#125; 4.3263472E7# HELP jvm_memory_bytes_committed Committed (bytes) of a given JVM memory area.# TYPE jvm_memory_bytes_committed gaugejvm_memory_bytes_committed&#123;area=\"heap\",&#125; 1.6777216E8jvm_memory_bytes_committed&#123;area=\"nonheap\",&#125; 4.5481984E7# HELP jvm_memory_bytes_max Max (bytes) of a given JVM memory area.# TYPE jvm_memory_bytes_max gaugejvm_memory_bytes_max&#123;area=\"heap\",&#125; 1.908932608E9jvm_memory_bytes_max&#123;area=\"nonheap\",&#125; -1.0# HELP jvm_memory_bytes_init Initial bytes of a given JVM memory area.# TYPE jvm_memory_bytes_init gaugejvm_memory_bytes_init&#123;area=\"heap\",&#125; 1.34217728E8jvm_memory_bytes_init&#123;area=\"nonheap\",&#125; 2555904.0# HELP jvm_memory_pool_bytes_used Used bytes of a given JVM memory pool.# TYPE jvm_memory_pool_bytes_used gaugejvm_memory_pool_bytes_used&#123;pool=\"Code Cache\",&#125; 7142976.0jvm_memory_pool_bytes_used&#123;pool=\"Metaspace\",&#125; 3.1820632E7jvm_memory_pool_bytes_used&#123;pool=\"Compressed Class Space\",&#125; 4299864.0jvm_memory_pool_bytes_used&#123;pool=\"PS Eden Space\",&#125; 5.7521336E7jvm_memory_pool_bytes_used&#123;pool=\"PS Survivor Space\",&#125; 8909040.0jvm_memory_pool_bytes_used&#123;pool=\"PS Old Gen\",&#125; 1.4385136E7... 값을 보게 되면 JVM에 사용되는 메트릭에 대한 정보가 export되었다는 걸 알 수 있다 실제 DefaultExports.initialize(); 가 어떻게 구현되었는지를 보면 어떤 정보가 export되는지 볼 수 있는데 1234567891011121314public static synchronized void initialize() &#123; if (!initialized) &#123; (new StandardExports()).register(); (new MemoryPoolsExports()).register(); (new MemoryAllocationExports()).register(); (new BufferPoolsExports()).register(); (new GarbageCollectorExports()).register(); (new ThreadExports()).register(); (new ClassLoadingExports()).register(); (new VersionInfoExports()).register(); initialized = true; &#125;&#125; 메모리와 쓰레드, 그리고 GC등에 대한 정보를 가져와서 등록하는 부분이 있는걸 볼 수 있다. 이제 JVM에 관련된 메트릭 말고 실제 원하는 메트릭을 export를 해봐야 하는데, 그러기 위해서는 export를 할 수 있는 metric의 타입이 어떤것들이 있는지부터 알아보고 가야한다 상세 설명 및 정보는 공식 홈페이지에(https://prometheus.io/docs/concepts/metric_types/) 있다. 크게 4가지의 메트릭 타입이 존재한다. Counter값을 나타내는 메트릭인데, “증가”만 할 수 있는 메트릭이라고 보면 된다. 카운터는 값을 증감시키거나, 0으로 초기화해서 다시 시작하거나 하는 기능만 지원을 한다. 그렇기 때문에 좀 제한적인 부분에만 사용을 할 수 있을 것 같은데, 아래와 같은 경우에 사용이 가능하지 않을까 싶다. http total send bytes http total request running time Gauge게이지는 카운터와 개념은 같지만, 값이 “증감”하거나 “감소”할 수 있다. 따라서 하나의 값을 나타내는 경우에는 대부분 게이지를 사용을 해서 구현을 하면 될 것 같다. temperature current cpu usage current thread count … Histogram특정 기간동안 측정된 값을 표현할 때 사용한다. 모든 메트릭 데이터의 합계를 제공하고 quantile을 계산(0.95, 0.99 …) 할 수 있도록 지원한다. TPS(Transaction per second) 특정 기간동안의 집계나 API 콜 수 등을 보고싶을때 Summary히스토그램과 비슷하지만, φ-quantiles을 지원한다는 점이 차이점이고 슬라이딩 시간단위의 윈도우를 계산할때 사용한다(이건 사실 무슨 소리인지 잘 모르겠다 언제 써야할지..) Gauge 사용해보기12345678910111213141516@RestController@Slf4jpublic class SampleController &#123; private Gauge sampleGauge; @PostConstruct public void init() &#123; sampleGauge = Gauge.build(\"sample\", \"sample metrics\").register(); &#125; @GetMapping public String sample() &#123; sampleGauge.inc(); return \"sample\"; &#125;&#125; Gauge를 사용해봤는데, 위와 같이 사용을 하면 된다. Gauge의 build를 통해서 메트릭의 이름을 지정해주고 이를 register(); 해주면 해당 메트릭이 등록이 되게 된다. 그리고 sample을 호출할때마다 sampleGauge의 값이 inc가 된다. 123# HELP sample sample metrics# TYPE sample gaugesample 0.0 처음에 spring boot를 띄우게 되면 9090포트로 위와같은 메트릭이 export가 되게 되는데, localhost:8080으로 sample을 호출을 하게 되면 위의 sample값이 1.0 , 2.0 … 와 같이 변하게 된다. 1Counter.build(\"someCounter\", \"Some counter\").register(); Counter의 경우에도 위와같이 build -&gt; register를 하게 되면 metric에 등록이 되게 된다. 간단한 gauge랑 counter의 경우는 위와같이 쓰면 되지만 실제로 많이 사용하게 될 메트릭들은 대부분 histogram과 summary일텐데 이건 공부가 좀더 필요해보인다. spring boot prometheus client(micrometer)를 기본으로 export하면 대부분 summary를 많이 사용하는 걸로 보인다(histogram은 안쓰고 summary만 씀) Spring boot exportercustom하게 metric을 export하는건 위에서 아주 살짝 맛만 봤는데, 실제로 잘 구현된 metric은 어떻게 구성되는지를 한번 알아보자. spring boot의 경우 actuator를 사용하면 별도의 설정없이 tomcat, jvm, spring에 관련된 정보를 export할 수 있다. (https://dzone.com/articles/monitoring-using-spring-boot-2-prometheus-and-graf) 123456789101112131415&lt;!-- Spring boot actuator to expose metrics endpoint --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- Micormeter core dependecy --&gt;&lt;dependency&gt; &lt;groupId&gt;io.micrometer&lt;/groupId&gt; &lt;artifactId&gt;micrometer-core&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- Micrometer Prometheus registry --&gt;&lt;dependency&gt; &lt;groupId&gt;io.micrometer&lt;/groupId&gt; &lt;artifactId&gt;micrometer-registry-prometheus&lt;/artifactId&gt;&lt;/dependency&gt; pom.xml에 위의 dependency를 import하고 123456#Metrics related configurationsmanagement.endpoint.metrics.enabled=truemanagement.endpoints.web.exposure.include=*management.endpoint.prometheus.enabled=truemanagement.metrics.export.prometheus.enabled=true application.properties에 위와 같은 config를 넣어주게 되면 localhost:8080/actuator/prometheus로 metric이 export되게 된다 그리고 grafana에서 보여지게 될 tag를 붙여줘야 한다 @Configuration 클래스를 하나 만들어서 아래의 bean을 등록해주자 12345678@Configuration@Slf4jpublic class PrometheusCustomConfig &#123; @Bean MeterRegistryCustomizer&lt;MeterRegistry&gt; metricsCommonTags() &#123; return registry -&gt; registry.config().commonTags(\"application\", \"PROMETHEUS-SAMPLE-SERVER\"); &#125;&#125; 이렇게 해야 grafana에서 여러개의 scrape target이 있을때 tag를 가지고 구분을 할 수 있게 된다. 12345678910# HELP http_server_requests_seconds # TYPE http_server_requests_seconds summaryhttp_server_requests_seconds_count&#123;exception=\"None\",method=\"GET\",outcome=\"SUCCESS\",status=\"200\",uri=\"/actuator/prometheus\",&#125; 1.0http_server_requests_seconds_sum&#123;exception=\"None\",method=\"GET\",outcome=\"SUCCESS\",status=\"200\",uri=\"/actuator/prometheus\",&#125; 0.083506614http_server_requests_seconds_count&#123;exception=\"None\",method=\"GET\",outcome=\"SUCCESS\",status=\"200\",uri=\"/\",&#125; 5.0http_server_requests_seconds_sum&#123;exception=\"None\",method=\"GET\",outcome=\"SUCCESS\",status=\"200\",uri=\"/\",&#125; 0.094335788http_server_requests_seconds_count&#123;exception=\"None\",method=\"GET\",outcome=\"SUCCESS\",status=\"200\",uri=\"/**/favicon.ico\",&#125; 4.0http_server_requests_seconds_sum&#123;exception=\"None\",method=\"GET\",outcome=\"SUCCESS\",status=\"200\",uri=\"/**/favicon.ico\",&#125; 0.042993164http_server_requests_seconds_count&#123;exception=\"None\",method=\"GET\",outcome=\"SUCCESS\",status=\"200\",uri=\"/actuator\",&#125; 1.0http_server_requests_seconds_sum&#123;exception=\"None\",method=\"GET\",outcome=\"SUCCESS\",status=\"200\",uri=\"/actuator\",&#125; 0.073100047 한 예로, http server의 RPS(Request per second)의 경우에 위와 같이 export를 해주는데, 보면 uri와 httpStatus, method 등을 나타내준다. 이를 시간별로 sum, count값을 보여주므로 그래프에 표현하게 되면 시간대별 HTTP 호출 그래프를 그릴 수 있다(Grafana) Prometheus Server에 메트릭 수집하기위 서버를 구동시켜두고(8080포트) prometheus에서 이 서버로의 metric을 수집해보도록 config파일을 바꿔보자(공유기 내부 네트워크라서 192.168.0.x 로 설정을 했지만, 실 서비스에서는 prometheus서버가 metric export를 하는 서버에 http(80)으로 접근이 가능해야 수집이 가능하다) 그리고 spring boot metric exporter를 사용하게 되면 scrape path가 달라져야 하는데, 기본으로는 host 주소를 적은 뒤 “/metrics”에서 긁어오지만 spring boot의 경우는 /actuator/prometheus에서 가져오기 때문에 아래와 같이 설정을 바꿔줘야 한다 12345678910111213141516171819202122232425262728# my global configglobal: scrape_interval: 1s # Set the scrape interval to every 15 seconds. Default is every 1 minute. evaluation_interval: 1s # Evaluate rules every 15 seconds. The default is every 1 minute. # scrape_timeout is set to the global default (10s).# Alertmanager configurationalerting: alertmanagers: - static_configs: - targets: # - alertmanager:9093# Load rules once and periodically evaluate them according to the global 'evaluation_interval'.rule_files: # - \"first_rules.yml\" # - \"second_rules.yml\"# A scrape configuration containing exactly one endpoint to scrape:# Here it's Prometheus itself.scrape_configs: # The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config. - job_name: 'prometeus-sample-server' # metrics_path defaults to '/metrics' # scheme defaults to 'http'. metrics_path: '/actuator/prometheus' static_configs: - targets: ['192.168.0.3:8080'] 보면 scrape_configs에 metrics_path가 설정되었는데, 기본으로는 metrics지만 이를 actuator/prometheus로 변경해주는 부분이다. 이렇게 설정하고 잘 실행이 되면 prometheus dashboard를 가서 확인해보자 아무거나(http_server_requests_second를 골랐다) 선택해서 execute를 한 뒤 그래프를 확인해보면 위와같이 잘 나오는걸 알 수 있다. Grafana에서 그래프 연동하기사실 이부분은 손이 매우많이 가기도 하고 어려운 부분이지만, 다행히도 이를 간편화해서 대시보드를 만들어놓으신분들이 있으셔서 grafana 공식 홈페이지에서 이를 받아서 사용할 수 있다 http://docs.grafana.org/installation/debian/ 에서 다운로드를 받아서 서버에 설치하자 이런 훌륭한 대시보드를 미리 만들어뒀으니 갖다 써보자. 써보려고 하는 대시보드는JVM(Micrometer) 이다(https://grafana.com/dashboards/4701) Datasource 등록하기 : http://docs.grafana.org/guides/getting_started/ Dashboard import하기 : http://docs.grafana.org/reference/export_import/ 성공적으로 Datasource와 Dashboard를 import했다면 대시보드에 접근해보자. 아래와 같은 화면이 나올 것이다. 이 대시보드는 현재 Spring boot에서 내보내는 metric을 Prometheus 서버가 scrape해서 데이터를 가져왔고, 저장된 데이터를 기준으로 Grafana에서 보여주고 있는 것이다. 사실 간단한 연동이라고 해서 진행을 했지만 도중에 어려운 부분이 하나씩 있을테니 가이드를 보면서 차근차근 도전해보는게 좋다. 사실 Prometheus로 시작했지만, 끝 마무리는 Grafana로 맺게 되는데.. Grafana를 약식으로 소개해서 그렇지 이 하나만 가지고도 여러개의 포스팅이 나올 수 있을만큼 강력하고 간단한 오픈소스 대시보드 솔루션이다. 이렇게 구성을 해두면 서비스를 하면서 문제가 생길만한 포인트를 사전에 알아본다던지, 현재 문제가 발생하는 부분이 어디에서 나는지(어떤 API가 현재 몇 TPS, Response time은 괜찮은지) 에 대한 정보를 얻을 수 있게 된다. 아무래도 devOps같은걸 하다보면 실제 개발만 하고 끝나는게 아니라 운영과 모니터링을 해야 하는데 그런 부분에서 Prometheus와 Grafana는 이런 정보를 얻기에 정말 간편한 구조를 채택하고 있음이 분명하고, 잘 활용을 한다면 높은 SLA 를 유지하는데 도움이 될 것이다.","categories":[{"name":"Monitoring","slug":"Monitoring","permalink":"https://gompangs.github.io/categories/Monitoring/"}],"tags":[{"name":"java","slug":"java","permalink":"https://gompangs.github.io/tags/java/"},{"name":"prometheus","slug":"prometheus","permalink":"https://gompangs.github.io/tags/prometheus/"},{"name":"prometheus java client","slug":"prometheus-java-client","permalink":"https://gompangs.github.io/tags/prometheus-java-client/"},{"name":"grafana","slug":"grafana","permalink":"https://gompangs.github.io/tags/grafana/"},{"name":"monitoring","slug":"monitoring","permalink":"https://gompangs.github.io/tags/monitoring/"},{"name":"모니터링","slug":"모니터링","permalink":"https://gompangs.github.io/tags/모니터링/"}]}]}